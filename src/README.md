## 数据结构

- **线性结构**

- 数组；栈；队列；链表；哈希表

- **树结构**

- 二叉树；二分搜索树；AVL；红黑树；Treap;Splay; 堆；Trie;线段树；K-D树；并查集；哈夫曼树；等等

- **图结构**

- 邻接矩阵；邻接表；


**数据结构的应用**

> 数据库系统

1. AVL;红黑树;Treap;伸展树;B树;
2. 哈希表

> 操作系统

*多任务切换*

1. 系统栈;优先队列:堆


> 文件压缩

1. 哈夫曼树  (比较简单的压缩算法)

> 通讯录

1. Trie - 前缀树


**大量的算法，以数据结构为基石**

> 游戏中的寻路算法

1. 图论算法:
    1. DFS:使用栈
    2. BFS:使用队列


**数据结构 + 算法 = 程序**




todo:

1. **数组**
2. **二分搜索树**
3. **栈**
4. **堆**
5. **队列**
6. **链表**
7.并查集
8. 线段树
9. Trie
10.AVL
11. 红黑树
12. 哈希表

https://github.com/liuyubobobo/Play-with-Data-Structures




### 时间复杂度分析

- O(1) \ O(n) \ O(lgn) \ O(nlogn) \ O(n^2)
- 大O描述的是算法运行时间和输入数据之间的关系
- 忽略掉的常数:**实际时间:** T=c1*n+c2 

- 栗子：  
    - T = 2*n + 2   -> O(n)
    - T = 2000*n + 10000   -> O(n)
    - T = 1\*n*n + O     ->  O(n^2)
    - T = 2\*n*n + 300n + 10    -> O(n^2)   '300n'这样的低阶项将会被忽略，当n趋近于无穷时n起的作用已微乎其微。

> 渐进时间复杂度
> 描述n趋近于无穷的情况


----

- 增: O(n)  \ 
              如果只对最后一个元素操作,依然是O(n)?还是 O(1)? O(n), 因为会 resize  
- 删: O(n)  /
- 改: 已知索引 O(1); 未知索引 O(n)
- 查: 已知索引 O(1); 未知索引 O(n)




##### resize 的复杂度分析


> 均摊复杂度  amortized time complexity

addLast 的均摊复杂度为 O(1)                      \
                                                  复杂度震荡                  
同理，我们看 removeLast 操作，均摊复杂度也为 O(1)  /


> 复杂度震荡: 当同时触发  addLast 与 removeLast 时，它们将会同时缩容或扩容(resize)，

*出现问题的原因: removeLast时 resize 过于着急(Eager)*


**复杂度震荡的解决方案：Lazy**

 √ 降低缩容与扩容的阈值

> 当 size == capacity / 4 时，才将 capacity 减半


*在算法领域，有的时候我们懒一些，算法的整体性能反而会更好*






### 栈 Stack


- 栈是一种后进先出的数据结构
- Last In First Out  (LIFO)
- 在计算机的世界里，栈拥有着不可思议的作用



**栈的应用**

- 无处不在的 Undo 操作 （撤销）
- 程序调用的系统栈
- 括号匹配-编译器 



**栈的实现**

Stack<E>

- void push(E)    -- 入栈
- E pop()    --  出栈
- E peek()  -- 看一下栈顶的元素是什么
- int getSize()  -- 栈中共有多少元素
- boolean isEmpty()  -- 栈是否为空



- 从用户角度看，支持这些操作就好
- 具体底层实现，用户不关心
- 实际底层有多种实现方式






#### 队列 Queue

- 队列也是一种线性结构
- 相比数组，队列对应的操作是数组的子集
- 只能从一端 (队尾) 添加元素，只能从另一端 (队首) 取出元素

*启发：生活中的排队?*


- 队列是一种先进先出的数据结构 (先到先得)
- First In First Out (FIFO)


**队列的实现**

Queue<E>

- void enqueue(E)     -->  入队             --> O(1)  均摊
- E dequeue()         -->  出队             --> O(n)   -?>> 循环队列的实现
- E getFront()        -->  获取队首元素      --> O(1)
- int getSize()       -->  队中的元素        --> O(1)
- boolean isEmpty()   -->  该队列是否为空    --> O(1)




**循环队列**

1. front == tail 队列为空
2. tail + 1 == front 队列满
3. (tail + 1) % c == front 队列满    -->  c 为 capacity

**data** 
    *front*  [a,b,c,d,e,f,g,...]  *tail*


> 在元素出队时，仅维护 *front* , 使其下标增 1. 直到*front*增到队列末尾时，
使用 *(front+1)%capacity* 求余，从而得到*front*之前所放弃的内存空间的下标，
这样循环的利用从而叫 **循环队列**

*在队列元素已满时，**front**之前一定要留一个空，即什么也不存储。否则将不满足 **front == tail 队列为空***

**所以capacity必须浪费一个空间**



















